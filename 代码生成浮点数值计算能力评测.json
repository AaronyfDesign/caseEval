{
    "input": [
        {
            "role": "user",
            "content": "实现函数double exp_minus_one(double x)，输入范围x∈[-1e-8, 1e-8]，要求避免相消误差，仅允许使用math.h库，禁止外部库和符号计算。测试样本包括：常规样本(x=5.3e-9, -7.1e-9)、边界样本(x=1e-12, -1e-15)、对抗样本(x=2.2e-308)。"
        }
    ],
    "target": "return expm1(x);",
    "output": {
        "role": "assistant",
        "content": "在实现 `double exp_minus_one(double x)` 函数，计算 $ e^x - 1 $ 且 **x ∈ [-1e-8, 1e-8]** 的极小值区间时，**直接使用 `exp(x) - 1` 会导致严重的相消误差（cancellation error）**，尤其是当 $ x $ 接近 0 时。\n\n### 📌 问题分析：相消误差\n- 当 $ x \\to 0 $，$ e^x \\to 1 $，所以 $ e^x - 1 $ 是 $ 1 - 1 $ 形式的减法。\n- 在浮点数表示中，`exp(x)` 和 `1.0` 非常接近，导致 **有效数字丢失**，精度严重下降。\n- 例如：`exp(1e-10) ≈ 1.0000000000999999...`，但 `1 - 1` 后只剩下最后几位，误差被放大。\n\n---\n\n### ✅ 解决方案：**使用 $ e^x - 1 $ 的泰勒展开**\n对于小 $ |x| \\ll 1 $，我们有：\n$$\ne^x - 1 = x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\cdots\n$$\n我们可以使用 **有限项泰勒展开（带余项补偿）** 来避免相消误差。\n\n但为了 **精度与效率** 的平衡，我们可以：\n1. **当 |x| 足够大（如 > 1e-8）时，使用 `expm1(x)`（如果可用）**，但题目要求 **仅用 `math.h`**，且 `expm1` 是 `math.h` 中的合法函数（C99 标准），**允许使用！**\n2. 但题目说：**仅允许使用 `math.h` 库** —— **`expm1` 是 `math.h` 提供的函数**，专门解决此问题！\n3. 然而，若 **不允许依赖 `expm1` 的底层实现**（比如在某些嵌入式系统中可能未实现），或想 **展示如何手动避免相消误差**，我们可以 **手动实现高精度展开**，并 **结合 `expm1` 作为 fallback**。\n\n但注意：**`expm1` 本身就是为解决 `exp(x) - 1` 的相消误差而设计的**，且精度极高，适用于极小 x。\n\n---\n\n### ✅ 最优策略（符合题目要求）：\n> **使用 `expm1(x)`，因为它是 `math.h` 的标准函数，专门处理此问题。**\n> 若担心某些系统未实现，可 **回退到高精度泰勒展开**。\n\n但题目允许 `math.h`，且 `expm1` 是标准函数，**强烈推荐使用**。\n\n然而，**题目说“避免相消误差，仅允许使用 math.h”** —— **`expm1` 就是标准答案**。\n\n但为了 **展示“如何手动避免相消误差”**（比如教学或禁用 `expm1` 的场景），我们可以：\n- 在 `|x|` 很小时（如 < 1e-4）使用 **带误差补偿的泰勒展开**\n- 否则使用 `expm1`（或 fallback 到 `exp(x)-1`，但 `expm1` 是更好的选择）\n\n> ⚠️ 注意：`expm1` 的精度远优于泰勒展开（尤其是大项相消），且经过充分优化。\n\n---\n\n### ✅ 最终方案：\n我们实现如下：\n- **如果 `|x|` 很大（> 1e-4），使用 `expm1(x)`（或 `exp(x)-1`，但 `expm1` 更优）**\n- **如果 `|x|` 很小，手动用泰勒展开（带补偿项）以避免误差**\n- 但 **`expm1(x)` 在 `|x| < 1e-4` 时也极其精确**，所以我们 **可以统一使用 `expm1(x)`**，除非特别要求手动实现。\n\n> ❗ 然而，**某些系统 `expm1` 可能实现不佳**？但现代 glibc、musl、OpenLibm 都实现得很好。\n\n但题目要求 **避免相消误差**，**`expm1` 正是为此而生**，且是 `math.h` 的一部分，**允许使用**。\n\n---\n\n### ✅ 推荐实现（使用 `expm1`）：\n```c\n#include <math.h",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 115,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数double optimized_sin(double x)，输入范围x∈[-1e-7, 1e-7]，要求优化|x|<1e-5的精度，保留负零符号，处理NaN/Inf传播。测试样本：极小角度(x=5e-8, -3e-9)、临界切换点(x=9.999e-6, -1.0001e-5)、零值(x=0.0, -0.0)。仅允许使用math.h库。"
        }
    ],
    "target": "if (isnan(x)) return x; if (isinf(x)) return NAN; if (x == 0.0) return x; if (fabs(x) < 1e-5) { double x2 = x * x; return x * (1.0 - x2/6.0 * (1.0 - x2/20.0)); } return sin(x);",
    "output": {
        "role": "assistant",
        "content": "在输入范围 $ x \\in [-1 \\times 10^{-7}, 1 \\times 10^{-7}] $ 内，要求高精度计算 `sin(x)`，并满足以下条件：\n\n- 精度优化在 $ |x| < 1e-5 $ 范围内（即使用泰勒展开足够精确）\n- 保留 **负零**（negative zero）符号\n- 正确处理 NaN / Inf（传播，不引入额外行为）\n- 仅使用 `math.h`\n- 测试用例包括极小值、临界点和零（正负）\n\n---\n\n### ✅ **设计思路**\n\n1. **泰勒展开**：  \n   对于极小的 $ x $，有：\n   $$\n   \\sin(x) = x - \\frac{x^3}{6} + \\frac{x^5}{120} - \\frac{x^7}{5040} + \\cdots\n   $$\n   当 $ |x| < 1e-5 $，$ x^7 \\approx 1e-35 $，在 double 下可忽略更高阶，但保留到 $ x^7 $ 可显著提升精度。\n\n2. **避免使用 `sin(x)` 直接调用**（虽然 `x` 很小，但 `libm` 的 `sin(x)` 可能不保证在极小值下完全保负零或最优精度，尤其在边界附近，我们需手动控制精度和符号）\n\n3. **保留负零**：\n   - 使用 `copysign` 或 `signbit`\n   - 注意：`x = -0.0` 时，`x*x` 是 `+0.0`，所以不能直接依赖平方项\n   - 但泰勒级数中奇次项保留符号，因此只要 **首项 `x` 正确，结果符号就正确**\n   - 特别处理 `-0.0`：确保返回 `-0.0`\n\n4. **处理 NaN / Inf**：\n   - 使用 `isnan()` 和 `isinf()` 检测输入\n   - 若输入是 NaN，返回 NaN（保留 payload，`math.h` 中 `NAN` 可表示）\n   - 若输入是 Inf，`sin(inf)` 应为 NaN（根据 IEEE 754 和 `math.h` 规范）\n\n5. **精度优化**：  \n   在 $ |x| < 1e-5 $ 使用 4 阶或 5 阶泰勒展开（保留 $ x^7 $ 项足够），在 $ |x| \\ge 1e-5 $ 可调用 `sin(x)`，但题目要求优化 $ |x| < 1e-5 $，且输入范围上限为 $ 1e-7 $，**实际上所有输入都小于 1e-5**，因此 **全部使用泰勒展开即可！**\n\n> ✅ 注意：题目输入范围是 $[-1e-7, 1e-7]$，而优化目标是 $ |x| < 1e-5 $，所以 **全部输入都满足泰勒展开高精度条件**，无需切换函数。\n\n---\n\n### ✅ **实现代码**\n\n```c\n#include <math.h>\n\ndouble optimized_sin(double x) {\n    // 处理 NaN\n    if (isnan(x)) {\n        return x;  // 传播 NaN，保持 payload\n    }\n\n    // 处理 ±Inf\n    if (isinf(x)) {\n        return NAN;  // sin(±Inf) = NaN\n    }\n\n    // 保留符号（用于负零检测）\n    int negative_zero = (x == 0.0 && signbit(x));\n\n    // 使用泰勒展开：sin(x) ≈ x - x^3/6 + x^5/120 - x^7/5040\n    // 所有项用 double 计算，避免中间溢出（因 x 极小）\n\n    double x2 = x * x;\n    double x3 = x2 * x;\n    double x5 = x3 * x2;\n    double x7 = x5 * x2;\n\n    double result = x - x3 / 6.0 + x5 / 120.0 - x7 / 5040.0;\n\n    // 检查是否为 -0.0：输入为 -0.0 时，result 可能是 +0.0（因 x2 等消去符号）\n    // 但我们希望返回 -0.0\n    if (result == 0.0 && negative_zero) {\n        result = -0.0;\n    }\n\n    return result;\n}\n```\n\n---\n\n### ✅ **关键设计说明**\n\n| ",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 127,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数Point global_min(double (*f)(double, double), Point domain)，求解测试函数f(x,y) = exp(sin(50*x)) + sin(60*exp(y)) + sin(70*sin(x)) + sin(sin(80*y)) - sin(10*(x+y)) + (x*x + y*y)/4在域x,y∈[-1,1]内的全局极小值。要求：混合精度策略(FP64+FP128)、自动检测梯度法失效、区间验证，最大函数评估次数1000000，目标精度15位数字。禁止使用符号计算库。"
        }
    ],
    "target": "DIRECT算法+Nelder-Mead精修+区间验证，最优解：x=-0.02440307923, y=0.2106124271, f_min=-3.306868647475",
    "output": {
        "role": "assistant",
        "content": "我们将实现一个**混合精度（FP64+FP128）的全局优化函数** `global_min`，用于求解如下测试函数的全局最小值：\n\n$$\nf(x,y) = \\exp(\\sin(50x)) + \\sin(60\\exp(y)) + \\sin(70\\sin(x)) + \\sin(\\sin(80y)) - \\sin(10(x+y)) + \\frac{x^2 + y^2}{4}\n$$\n\n在域 $ x, y \\in [-1, 1] $，目标精度 **15位有效数字**，最大函数评估次数 **1,000,000**，**禁止使用符号计算库**，**混合使用 FP64 与 FP128 精度**，并在梯度法失效时自动切换策略，**使用区间验证**。\n\n---\n\n### ✅ 设计思路\n\n#### 1. **混合精度策略**\n- **FP64 (double)**：用于大多数采样、局部优化、梯度计算（节省资源）\n- **FP128 (quad precision)**：在关键区域（如候选极小值点、验证阶段）使用高精度计算，提升数值稳定性\n\n> 使用 GCC 内建 `__float128` 类型（Linux/Unix）或 `boost::multiprecision::float128`（跨平台）。这里我们使用 `__float128` 并封装高精度函数。\n\n#### 2. **全局优化策略**\n- **多起点局部优化**（L-BFGS-B） + **随机重启** + **网格/拉丁超立方采样**\n- **梯度法失效检测**：梯度范数小但函数不降，或梯度方向与下降不符\n- **区间牛顿法 + 区间验证**用于验证候选解是否满足精度（使用区间算术验证局部唯一性）\n- **自适应切换**：若梯度法失败，启用更鲁棒的策略（如 Nelder-Mead、区间收缩）\n\n#### 3. **梯度计算**\n- 使用**中心差分法**，在 FP64 下计算梯度，若残差过大，切换 FP128\n\n#### 4. **区间验证**\n- 使用 `boost::numeric::interval` 或手动实现 FP128 区间运算（我们手动实现基于 `__float128` 的区间算术）\n\n#### 5. **精度控制**\n- 最终结果在 FP128 下评估，比较候选点函数值，保留满足 $ |f(x) - f_{\\min}| < 10^{-15} $ 的点\n\n---\n\n### ✅ 实现代码（C++）\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <random>\n#include <chrono>\n#include <iomanip>\n#include <limits>\n\n// For __float128 (quad precision)\nextern \"C\" {\n    #include <quadmath.h>\n}\n\n// Point structure\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double s) const { return Point(x * s, y * s); }\n    Point& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n    double norm() const { return std::sqrt(x*x + y*y); }\n};\n\n// High-precision point using __float128\nstruct QPoint {\n    __float128 x, y;\n    QPoint(__float128 x = 0, __float128 y = 0) : x(x), y(y) {}\n    QPoint(const Point& p) : x(p.x), y(p.y) {}\n};\n\n// Convert __float128 to double for output\ndouble to_double(__float128 f128) {\n    char buf[64];\n    quadmath_snprintf(buf, sizeof(buf), \"%.30Qe\", f128);\n    return std::atof(buf);\n}\n\n// FP128 math functions (wrappers)\n__float128 qsin(__float128 x) { return sincosq(x, nullptr); }\n__float128 qcos(__float128 x) { return cosq(x); }\n__float128 qexp(__float128 x) { return expq(x); }\n__float128 qpow(__float128 x, int n) { return expq(n",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 154,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数double adaptive_integrate(double (*f)(double), double a, double b)，计算积分f(x) = [sin(x)/(x*sqrt(1+x²))] * exp(-x/100)在∫₀^∞上的值。要求：自动变换选择、动态精度调整（1e-6→1e-20）、理论截断误差推导，最大函数评估次数10000000，目标精度20位有效数字。禁止使用符号计算。"
        }
    ],
    "target": "自动选择exp-sinh或tanh-sinh变换，动态精度控制，误差估计导向的采样密度调整",
    "output": {
        "role": "assistant",
        "content": "我们将实现一个**高精度自适应数值积分函数** `adaptive_integrate`，用于计算如下无穷区间的积分：\n\n$$\n\\int_0^\\infty \\frac{\\sin x}{x \\sqrt{1 + x^2}} e^{-x/100} \\, dx\n$$\n\n---\n\n### ✅ **核心要求分解**\n\n1. **无穷积分** → 需要**变量变换到有限区间**\n2. **高精度** → 1e-20（20位有效数字）\n3. **自适应精度调整**：从 `1e-6` 开始，逐步收紧容差，直到达到目标精度\n4. **最大函数调用次数**：10,000,000\n5. **动态步长与子区间划分**：使用**自适应 Simpson 法或自适应 Romberg 法**\n6. **误差控制**：基于**理论截断误差推导**（Simpson 误差估计）\n7. **禁止使用符号计算** → 全部数值实现\n8. **自动变换选择** → 对无穷区间使用**变量替换**\n\n---\n\n## 🚀 解决方案设计\n\n### 1. **无穷积分变换 → 有限区间**\n\n使用 **变量替换** $ x = \\frac{t}{1 - t} $，当 $ t \\in [0,1) $，$ x \\in [0,\\infty) $\n\n则：\n$$\ndx = \\frac{1}{(1 - t)^2} dt\n$$\n代入积分：\n$$\nI = \\int_0^1 f\\left(\\frac{t}{1-t}\\right) \\cdot \\frac{1}{(1 - t)^2} dt\n$$\n\n令 $ x = \\frac{t}{1 - t} \\Rightarrow t = \\frac{x}{1+x} $\n\n变换后的被积函数为：\n$$\ng(t) = f\\left(\\frac{t}{1-t}\\right) \\cdot \\frac{1}{(1 - t)^2}\n$$\n\n**优点**：\n- 将 $[0, \\infty)$ 映射到 $[0,1)$，且变换光滑，适合数值积分\n- 在 $ t \\to 1^- $ 时，$ g(t) $ 衰减较快（指数项主导）\n\n> ✅ **自动变换选择**：我们使用这个变换作为标准，因为它在 $ x \\to \\infty $ 时 $ dx/dt $ 增长合理，且函数平滑。\n\n---\n\n### 2. **自适应积分方法：自适应 Simpson 法（递归）**\n\n使用 **自适应 Simpson 法则**，基于**局部误差估计**递归细分。\n\n#### **Simpson 公式**：\n对区间 $[a,b]$，设中点 $ m = (a+b)/2 $\n$$\nS_1 = \\frac{b-a}{6} \\left[ f(a) + 4f(m) + f(b) \\right]\n$$\n$$\nS_2 = \\frac{m-a}{6} \\left[ f(a) + 4f(a+m/2) + f(m) \\right] + \\frac{b-m}{6} \\left[ f(m) + 4f((m+b)/2) + f(b) \\right]\n$$\n误差估计：\n$$\nE = \\frac{1}{15} |S_2 - S_1| \\quad \\text{(理论截断误差，Simpson 5 阶)}\n$$\n\n> ✅ **理论截断误差推导**：\n> Simpson 公式基于三次插值，局部误差为：\n> $$\n> E = \\frac{(b-a)^5}{2880} |f^{(4)}(\\xi)|, \\quad \\xi \\in (a,b)\n> $$\n> 但我们**无法知道四阶导数**，所以用 **Richardson 外推误差**：\n> $$\n> E \\approx \\frac{|S_2 - S_1|}{15} \\quad \\text{(因 } S_2 \\text{ 是 } S_1 \\text{ 的二阶近似，误差 } O(h^4) \\to O(h^5) \\text{ 外推)}\n> $$\n> 这是我们**动态误差估计**的基础。\n\n---\n\n### 3. **动态精度调整策略**\n\n我们不直接使用固定容差，而是：\n\n- 初始容差：`eps = 1e-6`\n- 每次递归成功，记录当前精度\n- 若未达到 `1e-20`，**整体重新积分，收紧容差**（如 `eps *= 0.1`），直到满足或超调用次数\n- 使用 **迭代收紧法（Iterative refinement）**\n\n> ✅ 动态精度调整：通过**多轮积分**，每轮提高精度要求，直到结果稳定到 20 位有效数字",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 121,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数void direct_sum(mpf_t result)计算级数S = Σ_{n=1}^{200} (-1)^n * n! / (10^n (n-10)^3)。要求：使用GMP库、精确计算n!、检测分母(n-10)^3接近零、处理中间项溢出，至少2000位精度，结果保留15位有效数字。"
        }
    ],
    "target": "使用GMP高精度库实现精确n!计算，检测n≥172的阶乘溢出",
    "output": {
        "role": "assistant",
        "content": "下面是一个使用 **GMP（GNU Multiple Precision Arithmetic Library）** 实现高精度计算函数 `void direct_sum(mpf_t result)` 的完整 C 语言实现，满足你提出的所有要求：\n\n---\n\n### ✅ **功能要求总结**\n1. **级数**：\n   $$\n   S = \\sum_{n=1}^{200} (-1)^n \\cdot \\frac{n!}{10^n (n-10)^3}\n   $$\n2. 使用 **GMP 库**（高精度浮点）。\n3. **精确计算 `n!`** → 使用 `mpz` 精确计算阶乘，再转 `mpf`。\n4. **检测分母 `(n-10)^3` 接近零** → 当 `n=10` 时分母为零，需特殊处理。\n5. **处理中间项溢出** → 使用足够高的精度（≥2000 位）。\n6. **结果保留 15 位有效数字** → 设置 `mpf_set_default_prec(2000 * 3.32)`（约 2048 bits）。\n7. 输出结果四舍五入到 **15 位有效数字**。\n\n---\n\n### ✅ **关键策略**\n- 使用 `mpf_t`（浮点数）和 `mpz_t`（整数）混合计算。\n- 阶乘用 `mpz_fac_ui`（GMP 提供）。\n- 分母 `(n-10)^3` 用 `mpz` 精确表示（整数）。\n- 避免浮点误差累积，所有中间步骤使用高精度。\n- `n=10` 时跳过或处理为极限（但实际为 **0/0 型奇点**，但级数中 `n=10` 时 `(n-10)^3 = 0`，**必须跳过或定义为 0**）。\n  - 注意：原式在 `n=10` 时分母为零 → **项无定义**。\n  - **数学上，该级数在 n=10 处发散？但分子 `n!` 增长极快，而分母为 0 → ∞**。\n  - 但 `(n-10)^3` 在 `n=10` 为 0，**除非有抵消，否则此项发散**。\n\n🔍 **关键观察**：  \n虽然 `n=10` 时 `(n-10)^3 = 0`，但分子是 `10!`，分母为 0 → **该项为 ∞**，但符号为 `(-1)^10 = +1` → 正无穷。\n\n⚠️ **但这是数学问题**：该级数在 `n=10` 处是 **发散的**（除非你定义极限，但此处是精确计算）。\n\n✅ **合理做法**：  \n**跳过 `n=10`**，或视为 **数值计算中忽略奇点项**，并在注释中说明。  \n> 实际上，若 `(n-10)^3` 是精确零，该项无法计算。因此我们 **跳过 n=10**，并输出警告（可选）。\n\n> 若你希望更数学化处理（如主值、正则化），需额外信息。这里按“跳过奇点”处理，**在实现中跳过 n=10**。\n\n---\n\n### ✅ **代码实现**\n\n```c\n#include <stdio.h>\n#include <gmp.h>\n#include <math.h>\n\nvoid direct_sum(mpf_t result) {\n    // 设置高精度：2000位十进制 ≈ 2000 * log2(10) ≈ 6650 bits，取 7000 位更安全\n    mpf_set_default_prec(7000);  // 约 2100 十进制位，远超 2000\n\n    mpf_t sum, term, temp_mpf, factorial_f;  // 浮点变量\n    mpf_t power_of_10, denom;\n    mpz_t factorial_z;           // n! 的整数形式（精确）\n    mpz_t n_minus_10;\n    mpf_t abs_n_minus_10;\n    mpz_t abs_cubed_z;\n    mpf_t abs_cubed_f;\n\n    mpf_init(sum); mpf_init(term); mpf_init(temp_mpf);\n    mpf_init(power_of_10); mpf_init(denom);\n    mpf_init(abs_n_minus",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 100,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数double compound_value(double principal, double rate, int years)，计算复利终值。输入范围：principal∈[1,1e9]USD，rate∈[0,0.3]年利率，years∈[0,100]整数。要求零利率时返回本金，小利率高精度(rate<1e-5)，长期计算优化(years>50)。仅允许使用math.h库。"
        }
    ],
    "target": "if (rate == 0.0 || years == 0) return principal; if (rate < 1e-5) { double log_base = years * rate * (1 - rate/2); return principal * exp(log_base); } return principal * exp(years * log1p(rate));",
    "output": {
        "role": "assistant",
        "content": "```c\n#include <math.h>\n\ndouble compound_value(double principal, double rate, int years) {\n    // 输入边界检查（根据题目范围，可视为安全）\n    \n    // 零利率情况：直接返回本金\n    if (rate == 0.0 || years == 0) {\n        return principal;\n    }\n    \n    // 小利率高精度处理：当 rate 很小时，使用泰勒展开避免 pow 的浮点误差\n    // 当 rate < 1e-5 时，使用指数函数展开 e^(rate*years) ≈ 1 + rate*years + (rate*years)^2/2 + ...\n    // 但更高效的是使用 exp(years * log1p(rate))，但题目限制只能用 math.h 且 log1p 可能不可用\n    // 替代方案：对极小 rate，直接使用 exp(years * rate) 的泰勒展开或利用 expm1 思想\n    // 由于 math.h 中我们有 exp 和 log，但对小值精度问题，我们采用：\n    // (1+rate)^years = exp(years * ln(1+rate))，但 ln(1+x) ≈ x - x^2/2 + x^3/3 - ... 当 x 小时\n    // 为避免 ln(1+rate) 的精度损失，当 |rate| < 1e-5 时，使用 ln(1+rate) ≈ rate*(1 - rate/2*(1 - rate/3*(1 - ...)))\n    // 更简单且稳定：使用 exp(years * log1p(rate)) 是理想方式，但 log1p 不在所有 math.h 实现中\n    // 因此我们使用：当 rate 很小时，用泰勒展开计算 (1+rate)^years = e^(years * rate - years*(rate^2)/2 + ...)\n    // 但更高效且精确的方法是：当 rate < 1e-5，使用 exp(years * rate) * exp(-years*rate^2/2) * ... \n    // 但最实用的是：使用 exp(years * (rate - rate*rate/2 + ... )) —— 我们采用三阶展开\n    \n    // 然而，更稳健的做法是：对小 rate，使用自然对数展开：\n    // ln(1+rate) = rate - rate^2/2 + rate^3/3 - rate^4/4 + ...\n    // 当 |rate| < 1e-5 时，rate^3/3 < 1e-15，远小于 double 精度误差，因此取前两项\n    // 即：ln(1+rate) ≈ rate - rate^2/2\n    // 所以 (1+rate)^years ≈ exp(years * (rate - rate*rate/2))\n    \n    double factor;\n    if (rate < 1e-5 && rate > -1e-5) {  // 实际上 rate >= 0，但安全\n        // 使用泰勒展开 ln(1+rate) ≈ rate - rate^2/2 + rate^3/3 - ...\n        // 取前两项，误差在 rate^3/3 ≈ 1e-15，对 double 足够\n        double log_1plus_rate = rate - (rate * rate) / 2.0;\n        double exponent = years * log_1plus_rate;\n        \n        // 当 exponent 很小时，exp(exponent) ≈ 1 + exponent + exponent^2/2\n        // 但若 exponent 较大（如 years=100, rate=1e-5 => exponent=1e-3），仍可用 exp，但 exp 在 |x|<0.001 时精度好\n        if (fabs(exponent) < 1e-3) {\n            // 使用 exp 的二阶泰勒展开提高精度\n            factor = 1.0 + exponent + (exponent * exponent) / 2.0;\n        } else {\n            factor = exp(exponent);\n        }\n    } else {\n        // 正常情况：直接计算 (1+rate)^years\n        // 但 years 很大时（>50），pow(1.0 + rate, years) 可能因浮点误差累积而略失精确\n        // 优化：使用 exp(years * log(1.0 + rate))，这通常更稳定，尤其当 (1+rate) 接近 1\n        // 注意：1.0 + rate 在 [1.0, 1.3] 范围，log 计算稳定\n        factor = exp(years * log(1.0 + rate));\n    }\n    \n   ",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 105,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数double implied_volatility(double S, double K, double T, double r, double option_price)，计算期权隐含波动率。要求：ATM期权稳定性(|S/K-1|<0.01%)、短期期权精度(T<0.1)、除零防护(vega<1e-10)，使用牛顿迭代法，最大迭代10次，收敛阈值1e-8。仅允许使用math.h库。"
        }
    ],
    "target": "短期期权使用Brenner-Subrahmanyam近似，牛顿迭代法，vega<1e-10时切换二分法",
    "output": {
        "role": "assistant",
        "content": "以下是使用 **牛顿-拉夫逊法**（Newton-Raphson）计算期权隐含波动率 `implied_volatility` 的实现。该函数满足以下要求：\n\n- 仅使用 `math.h`\n- 支持 ATM 期权（|S/K - 1| < 0.01%）的稳定性\n- 短期期权（T < 0.1）高精度\n- 除零防护（Vega 接近零时退出）\n- 最大迭代 10 次\n- 收敛阈值 `1e-8`\n- 使用 Black-Scholes 模型（欧式期权）\n\n---\n\n### ✅ 实现说明：\n\n- **牛顿法公式**：  \n  $$\n  \\sigma_{n+1} = \\sigma_n - \\frac{BS(S,K,T,r,\\sigma_n) - \\text{option\\_price}}{Vega(S,K,T,r,\\sigma_n)}\n  $$\n\n- **初始猜测值**：  \n  使用 **Corrado & Miller (1996)** 近似公式，尤其适合 ATM 或短期期权。\n\n- **Vega**：Black-Scholes 的 vega 始终 > 0，但数值接近 0 时需防除零。\n\n- **收敛条件**：价格误差 `< 1e-8`\n\n- **边界保护**：σ ∈ [1e-4, 10]（避免负或极端波动率）\n\n---\n\n### ✅ 完整代码（仅用 `math.h`）：\n\n```c\n#include <math.h>\n\n// Black-Scholes call price and vega\nstatic void black_scholes(double S, double K, double T, double r, double sigma, double *call, double *vega) {\n    if (T <= 1e-8) {\n        *call = (S > K) ? S - K : 0.0;\n        *vega = 0.0;\n        return;\n    }\n\n    double d1, d2;\n    double sqrt_T = sqrt(T);\n\n    d1 = (log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt_T);\n    d2 = d1 - sigma * sqrt_T;\n\n    if (d1 > 0) {\n        *call = S * 0.5 * erfc(-d1 / sqrt(2)) - K * exp(-r * T) * 0.5 * erfc(-d2 / sqrt(2));\n    } else {\n        *call = S * 0.5 * (1 + erf(d1 / sqrt(2))) - K * exp(-r * T) * 0.5 * (1 + erf(d2 / sqrt(2)));\n    }\n\n    // Vega: S * sqrt(T) * N'(d1)\n    double pdf = (1.0 / sqrt(2.0 * M_PI)) * exp(-0.5 * d1 * d1);\n    *vega = S * sqrt_T * pdf;\n}\n\n// Corrado & Miller (1996) initial volatility guess\nstatic double initial_guess(double S, double K, double T, double r, double option_price) {\n    double intrinsic = (S - K > 0) ? S * exp(-r * T) - K * exp(-r * T) : 0.0;\n    if (option_price <= intrinsic) return 1e-4;\n\n    double x = (S + K) * 0.5;\n    double m = option_price - intrinsic;\n    double d = fabs(S - K);\n    double sigma0 = (M_PI_2 * m) / x;  // rough guess\n    double corr = 1.0 + (d / (M_PI * x));\n    sigma0 *= sqrt(-log(corr)) / sqrt(T);  // Corrado-Miller adjustment\n\n    // Fallback: if T too small or guess invalid, use simpler method\n    if (sigma0 <= 0.0 || isinf(sigma0) || isnan(sigma0)) {\n        double atm_vol = option_price / (S * sqrt(T) * 0.5 * sqrt(M_2_PI)); // rough ATM\n        sigma0 = (atm_vol < 1e-4) ? 0.2 : atm_vol;\n    }\n\n    // Clamp to reasonable range\n    return (sigma0 < 1e-4) ? 1e-4 : (sigma0 > 2.0) ? 2.0 : sigma0;\n}\n\ndouble implied_volatility(double S, double K, double T, double r, double option_price) {\n    // Input validation\n    if (S < 0 || K <= 0 || T < 0",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 107,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数double internal_rate_of_return(double* cash_flows, int n_periods)，计算内部收益率。输入：cash_flows数组(首期为负投资)，n_periods∈[2,30]。要求：现金流符号交替>3次时使用二分法混合牛顿法，|r|<0.005时泰勒展开(1+r)^t，智能初始估计，迭代上限20步，收敛阈值1e-8。仅用math.h基础函数。"
        }
    ],
    "target": "智能初始估计r₀=pow(终值/|初值|,1/T)-1，|r|<0.005时泰勒展开(1+r)^t，符号交替>3次时混合二分法",
    "output": {
        "role": "assistant",
        "content": "下面是符合你所有要求的 `internal_rate_of_return` 函数实现，**完全基于 `math.h` 基础函数**（如 `pow`, `exp`, `log`, `fabs`, `sqrt` 等），并实现了以下关键设计点：\n\n---\n\n### ✅ **功能说明**\n- 计算现金流数组的 **内部收益率 (IRR)**\n- 输入：`cash_flows[0..n_periods-1]`，首期通常为负（初始投资）\n- 使用 **智能初始估计**\n- 根据 **现金流符号变化次数** 决定是否使用 **二分法+牛顿法混合策略**\n- 在 `|r| < 0.005` 时使用 **泰勒展开近似 `(1+r)^t`** 加速计算\n- **最大迭代 20 步，收敛阈值 `1e-8`**\n- **不使用任何高级库，仅用 math.h**\n- 处理数值稳定性问题（如除零、负利率等）\n\n---\n\n### ✅ **核心策略**\n1. **符号变化 > 3 次** → 使用 **混合方法（先二分法，再牛顿）** 防止发散\n2. **符号变化 ≤ 3 次** → 使用 **牛顿法 + 智能初值**\n3. **|r| < 0.005** → 用泰勒展开 `(1+r)^t ≈ 1 + t*r + (t*(t-1)/2)*r^2` 提升精度\n4. **智能初值**：\n   - `r0 = (总现金流入 - 总流出) / 总流出`（近似）\n   - 若为负则设为 -0.5，正则设为 0.25，限制在 [-0.9, 1.0]\n\n---\n\n### ✅ 实现代码\n\n```c\n#include <math.h>\n\n// 计算净现值和导数（用于牛顿法）\nstatic void npv_and_deriv(double* cash_flows, int n_periods, double r, double* npv, double* deriv) {\n    double npv_val = 0.0;\n    double deriv_val = 0.0;\n    double r_power = 1.0;  // (1 + r)^t, start at t=0\n    double deriv_factor = 0.0;  // t / (1 + r), start at t=0\n\n    // 判断是否使用泰勒展开（小 |r| 时）\n    int use_taylor = fabs(r) < 0.005;\n\n    for (int t = 0; t < n_periods; t++) {\n        double cf = cash_flows[t];\n        double discount = 0.0;\n        double deriv_discount = 0.0;\n\n        if (use_taylor && t > 0) {\n            // Taylor expansion: (1+r)^t ≈ 1 + t*r + (t*(t-1)/2)*r^2\n            discount = 1.0 + t * r;\n            if (t > 1) discount += (t * (t - 1) / 2.0) * r * r;\n            // Derivative: d/dr[(1+r)^t] ≈ t + t*(t-1)*r\n            deriv_discount = t + (t * (t - 1.0)) * r;\n        } else if (t == 0) {\n            discount = 1.0;\n            deriv_discount = 0.0;\n        } else {\n            if (r > -1.0 + 1e-10) {\n                r_power *= (1.0 + r);  // 递推计算 (1+r)^t\n                discount = r_power;\n                deriv_discount = t * pow(1.0 + r, t - 1);  // t * (1+r)^(t-1)\n            } else {\n                // 防止除以零或负底数的幂（但 r > -1 是 IRR 定义域）\n                discount = 0.0;\n                deriv_discount = 0.0;\n            }\n        }\n\n        npv_val += cf * discount;\n        deriv_val += cf * deriv_discount;\n    }\n\n    *npv = npv_val;\n    *deriv = deriv_val;\n}\n\n// 计算符号变化次数\nstatic int count_sign_changes(double* cash_flows, int n_periods) {\n    int sign = cash_flows[0] >= 0 ? 1 : -1;\n    int changes = 0;\n    for (int i = 1; i < n_periods; i++) {\n        int cur_sign = cash_flows[i] >= 0 ?",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 114,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数double adaptive_singular_integral(double (*f)(double), double a, double b)，计算积分f(x) = x^{-0.9}/(1+1000(x-0.5)^2)在∫₀^1上的值。要求：x=0奇异性处理（双指数变换）、峰值区域检测(0.499, 0.501)、混合精度(FP64检测+FP128精修)，目标精度30位数字，最大函数评估次数100000000，峰值区域采样密度5000点/单位宽度。禁止符号预处理。"
        }
    ],
    "target": "区间拆分：part1=de_transform(f,0,0.499)，谱方法：part2=chebyshev_spectral(f,0.499,0.501,2000)，双指数变换：part3=de_transform(f,0.501,1)",
    "output": {
        "role": "assistant",
        "content": "为了实现函数 `double adaptive_singular_integral(double (*f)(double), double a, double b)`，目标是高精度计算如下积分：\n\n$$\n\\int_0^1 \\frac{x^{-0.9}}{1 + 1000(x - 0.5)^2} \\, dx\n$$\n\n该积分在 $ x = 0 $ 处具有 **弱奇异点**（阶为 $ x^{-0.9} $），在 $ x = 0.5 $ 处有 **尖锐峰值**（洛伦兹型，半高宽极小），因此需要：\n\n1. **双指数变换（DE变换）** 处理 $ x \\to 0 $ 的奇异性；\n2. **峰值区域自适应采样**：在 $ x \\in [0.499, 0.501] $ 内使用 **5000 点/单位宽度**（即总 10 点，但实际需更高密度，见后）；\n3. **混合精度策略**：使用 `double`（FP64）做初步检测与粗积分，`__float128`（或 `boost::multiprecision::float128`，若可用）做 **精修计算**，以达到 **30 位有效数字精度**；\n4. **禁止符号预处理**，即不使用 `SymPy`、`Mathematica` 等符号工具；\n5. **最大函数求值次数 100,000,000**；\n6. **自适应细分 + 局部高精度精修**。\n\n---\n\n### 🧩 设计思路\n\n#### 1. **双指数变换（DE）处理奇异性**\n- 对于 $ \\int_0^a f(x)\\,dx $，当 $ f(x) \\sim x^\\alpha $，使用 **DE 变换**：\n  $$\n  x = \\exp(-e^{-t}),\\quad dx = \\exp(-t - e^{-t}) dt\n  $$\n  可将奇异性平滑化，使函数在 $ t \\in (-\\infty, \\infty) $ 上光滑且快速衰减。\n\n- 但本积分在 $ [0,1] $，且 $ x=0 $ 奇异，但 $ x=1 $ 正常。我们可将 $[0,1]$ 拆为：\n  - $[0, \\epsilon]$：用 **DE 变换** 处理奇异性\n  - $[\\epsilon, 1]$：正常自适应积分，但 **在 [0.499,0.501] 区域强制高密度采样**\n\n- 选择 $ \\epsilon = 10^{-10} $，避免 $ x=0 $ 附近数值问题，但保留奇异性。\n\n#### 2. **峰值区域处理**\n- 峰值在 $ x=0.5 $，宽度约 $ \\sim 0.01 / \\sqrt{1000} \\approx 0.01 $，但题目要求 **5000 点/单位宽度**，即：\n  - 区间长度 $ 0.002 $（0.499–0.501） → 需 **10 个单位宽度** → 至少 $ 10 \\times 5000 = 50,000 $ 点。\n- 但自适应算法不应一开始就用这么多点，而是：\n  - **先用 FP64 检测峰值位置和宽度**\n  - **在检测到的峰值区域（0.499–0.501）内，使用局部高密度网格采样（如 50,000 点）并用 FP128 积分**\n  - 其余区域用自适应高斯求积（如 Gauss-Kronrod）\n\n#### 3. **混合精度**\n- 外层控制用 `double`，但：\n  - 在 **DE 变换积分段** 和 **峰值段** 的求和、权重计算用 `__float128`（GCC 支持）\n  - 最终累加用 `__float128`，最后转 `double` 返回（但实际精度由内部保证）\n\n#### 4. **自适应算法**\n- 使用 **递归自适应积分**（类似 QUADPACK 的 `dqags`）：\n  - 在 $[a,b]$ 上应用 Gauss-Kronrod 7-15 求积\n  - 若误差估计不满足容差，则二分递归\n  - 但在 **峰值区域强制不细分**，而是 **切换为密集网格 + 高精度积分**\n\n#### 5. **峰值检测**\n- 在 $[0.5 - 0.001, 0.",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 155,
    "output_token_num": 1024
}
{
    "input": [
        {
            "role": "user",
            "content": "实现函数struct EigenResult extreme_eigenpair(double A[4][4])，计算测试矩阵A = diag([1e-20, 1e-15, 1e-10, 1]) + random_ortho(4)*1e-25的最小特征值和特征向量。要求：条件数cond(A)=1e20，目标精度25位有效数字（最小特征值），200位精度运算，迭代精修，近似线性相关检测，最大计算时间1小时。禁止符号计算。"
        }
    ],
    "target": "平衡缩放：scale_matrix(A)，分块对角化：deflate_small_blocks(A, 1e-18)，高精度QR迭代：for(i=0; i<200; i++)，残差补偿：apply_kahan_compensation(eigenvec)",
    "output": {
        "role": "assistant",
        "content": "实现 `extreme_eigenpair` 函数，目标是 **高精度计算 4×4 矩阵 A 的最小特征值及其特征向量**，满足以下严苛要求：\n\n---\n\n### ✅ **目标**\n- **矩阵 A**：`A = diag([1e-20, 1e-15, 1e-10, 1]) + R * 1e-25`，其中 `R` 是 4×4 随机正交矩阵。\n- **条件数 cond(A) ≈ 1e20** ✅（已满足）\n- **目标精度**：\n  - 最小特征值：**25 位有效数字**\n  - 计算中使用 **200 位精度浮点运算**\n- **迭代精修**（Iterative Refinement）：用于提升精度\n- **检测近似线性相关性**：防止病态或秩亏损\n- **时间限制**：≤ 1 小时\n- **禁止符号计算**（即不能用 `sympy` 等符号系统，只能用数值算法 + 多精度浮点）\n\n---\n\n### ✅ **技术路线**\n1. **使用多精度浮点库**：`Boost.Multiprecision`（C++）或 `mpmath`（Python）→ 我们选择 **C++ + Boost.Multiprecision**（更高性能、可控性）\n2. **算法选择**：\n   - **Lanczos 算法（隐式重启）** 或 **Jacobi 特征值求解器（高精度）**\n   - 由于矩阵小（4×4），且需要高精度 + 迭代精修 → **使用高精度 Jacobi 特征值算法（经典 Jacobi 旋转）**\n   - 原因：4×4 足够小，Jacobi 方法收敛快，精度高，适合迭代精修。\n3. **正交矩阵生成**：用 QR 分解生成随机正交矩阵（避免符号计算）\n4. **迭代精修**：在低精度下快速迭代，然后用高精度残差修正\n5. **线性相关检测**：检查特征向量矩阵的条件数或 Gram 行列式\n6. **精度控制**：使用 200 位十进制精度的 `mpf_class`（来自 Boost）\n\n---\n\n## ✅ 完整 C++ 实现（使用 Boost.Multiprecision）\n\n> **依赖库**：[Boost.Multiprecision](https://www.boost.org/doc/libs/release/libs/multiprecision/)  \n> 编译命令示例：`g++ -O3 -lboost_system -lboost_multiprecision -lgmpxx -lgmp extreme_eigen.cpp -o eigen`\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <random>\n#include <boost/multiprecision/mpfr.hpp>\n#include <boost/multiprecision/number.hpp>\n\nnamespace mp = boost::multiprecision;\nusing mp_float = mp::number<mp::mpfr_float_backend<200>>;  // 200 decimal digits (~600 bits)\nusing mp_complex = std::complex<mp_float>;\n\n// 4x4 matrix and vector\ntemplate<int N>\nstruct Matrix {\n    mp_float data[N][N];\n    mp_float& operator()(int i, int j) { return data[i][j]; }\n    const mp_float& operator()(int i, int j) const { return data[i][j]; }\n};\n\ntemplate<int N>\nstruct Vector {\n    mp_float data[N];\n    mp_float& operator[](int i) { return data[i]; }\n    const mp_float& operator[](int i) const { return data[i]; }\n};\n\n// ==================== Random Orthogonal Matrix Generation ====================\ntemplate<int N>\nvoid generate_random_orthogonal(Matrix<N>& Q) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::normal_distribution<double> dist(0.0, 1.0);\n\n    // Generate random NxN matrix with double precision, then QR\n    double temp[N][N];\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            temp[i][j] = dist(gen);\n\n    // Classical Gram-Schmidt (numerically unstable but fine for small N, or use modified)\n    for (int i = 0; i < N; ++i) {\n        Vector<N> v;\n        for (int j = 0; j < N; ++j)\n            v[j] = temp[i][j];\n\n        for (int k = 0; k < i; ++k) {\n            Vector<N> qk;\n            for (int j = 0; j < N; ++j)\n                qk[j] =",
        "tool_calls": [],
        "task_id": null,
        "reasoning_content": "",
        "reasoning_details": null
    },
    "prompt_token_num": 127,
    "output_token_num": 1024
}